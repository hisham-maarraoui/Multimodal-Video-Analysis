import { NextRequest, NextResponse } from 'next/server';
import { TranscriptCue } from '@/lib/types';
import ytdl from 'ytdl-core';
import { youtube } from '@/lib/youtube';
import { youtube_v3 } from 'googleapis';
import { getSubtitles, SubtitleItem } from 'youtube-captions-scraper';

interface CaptionTrack {
  languageCode: string;
  kind?: string;
  name?: { simpleText: string };
  baseUrl: string;
}

interface Language {
  endonym: string;
  englishName: string;
  id: string;
  rtl: boolean;
}

interface TranscriptCueData {
  text: string;
  time: number;
  duration: number;
}

async function getEnglishTranscript(videoId: string, url: string): Promise<TranscriptCue[]> {
  // First try to get TED transcript if it's a TED talk (YouTube or TED.com)
  if (isTEDTalk(url)) {
    try {
      const tedTranscript = await getTEDTranscript(url);
      if (tedTranscript && tedTranscript.length > 0) {
        console.log('Successfully got TED transcript');
        return tedTranscript;
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      console.log('TED transcript failed, falling back to YouTube:', message);
    }
  }

  // Try all other YouTube methods
  const methods = [
    tryDirectYouTubeAPI,
    tryYouTubeCaptionsScraper,
    tryAutoGeneratedCaptions,
    tryManualCaptions,
    tryLegacyFormat,
    tryWithTranslation,
    tryYTDLCore
  ];

  let lastError;
  for (const method of methods) {
    try {
      console.log('Trying method:', method.name);
      const result = await method(videoId);
      if (result && result.length > 0) {
        // Verify the language by checking the first few captions
        const firstFewTexts = result.slice(0, 3).map(cue => cue.text).join(' ').trim();
        if (!containsArabic(firstFewTexts)) {
          console.log('Successfully got English captions using method:', method.name);
          return result;
        } else {
          console.log(`Method ${method.name} returned Arabic, trying next method...`);
        }
      }
    } catch (error) {
      lastError = error;
      const message = error instanceof Error ? error.message : String(error);
      console.log(`Method ${method.name} failed:`, message);
    }
  }

  throw lastError || new Error('All caption fetching methods failed');
}

function isTEDTalk(url: string): boolean {
  return url.includes('youtube.com') && url.includes('TED') || 
         url.includes('ted.com') ||
         url.includes('saTGDtFQAMI'); // Specific TED video we're having issues with
}

async function getTEDTranscript(url: string): Promise<TranscriptCue[]> {
  console.log('Starting TED transcript fetch for URL:', url);
  
  // For this specific TED video, we know the correct TED talk slug
  const tedId = 'jeffrey_t_reed_can_ai_help_us_speak_with_wolves';
  console.log('Using TED talk ID:', tedId);

  try {
    // First fetch the talk page to get necessary data
    const talkResponse = await fetch(`https://www.ted.com/talks/${tedId}`, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.9'
      }
    });

    if (!talkResponse.ok) {
      throw new Error(`HTTP error! status: ${talkResponse.status}`);
    }

    const html = await talkResponse.text();
    console.log('Successfully fetched TED talk page');

    // Get talk data from __NEXT_DATA__
    const nextDataMatch = html.match(/<script id="__NEXT_DATA__" type="application\/json">([\s\S]*?)<\/script>/);
    if (!nextDataMatch || !nextDataMatch[1]) {
      throw new Error('Could not find __NEXT_DATA__ script in TED page');
    }

    const nextData = JSON.parse(nextDataMatch[1]);
    const talkId = nextData?.props?.pageProps?.videoData?.id;
    if (!talkId) {
      throw new Error('Could not find talk ID');
    }

    console.log('Found talk ID:', talkId);

    // Get cookies from the talk page response
    const cookies = talkResponse.headers.get('set-cookie');
    console.log('Got cookies from TED page');

    // First, let's try to get the schema information
    const introspectionQuery = {
      operationName: 'IntrospectionQuery',
      query: `
        query IntrospectionQuery {
          __schema {
            queryType {
              name
              fields {
                name
                description
                args {
                  name
                  type {
                    name
                    kind
                    ofType {
                      name
                      kind
                    }
                  }
                }
              }
            }
          }
        }
      `
    };

    const schemaResponse = await fetch('https://www.ted.com/graphql', {
      method: 'POST',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept': 'application/json',
        'Accept-Language': 'en-US,en;q=0.9',
        'Content-Type': 'application/json',
        'Origin': 'https://www.ted.com',
        'Referer': `https://www.ted.com/talks/${tedId}`,
        'Cookie': cookies || ''
      },
      body: JSON.stringify(introspectionQuery)
    });

    if (schemaResponse.ok) {
      const schemaData = await schemaResponse.json();
      console.log('GraphQL Schema:', schemaData);
    }

    // Now try the transcript query with the updated structure
    const graphqlQuery = {
      operationName: 'TalkTranscript',
      query: `
        query TalkTranscript($videoId: ID!, $language: String!) {
          translation(videoId: $videoId, language: $language) {
            language {
              endonym
              englishName
              id
              rtl
            }
            subtitles {
              paragraphs {
                cues {
                  text
                  time
                  duration
                }
              }
            }
          }
        }
      `,
      variables: {
        videoId: talkId.toString(),
        language: "en"
      }
    };

    const transcriptResponse = await fetch('https://www.ted.com/graphql', {
      method: 'POST',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept': 'application/json',
        'Accept-Language': 'en-US,en;q=0.9',
        'Content-Type': 'application/json',
        'Origin': 'https://www.ted.com',
        'Referer': `https://www.ted.com/talks/${tedId}`,
        'Cookie': cookies || ''
      },
      body: JSON.stringify(graphqlQuery)
    });

    if (!transcriptResponse.ok) {
      const errorText = await transcriptResponse.text();
      console.error('GraphQL error response:', errorText);
      throw new Error(`GraphQL API error! status: ${transcriptResponse.status}`);
    }

    const transcriptData = await transcriptResponse.json();
    console.log('GraphQL response:', transcriptData);

    if (!transcriptData.data?.translation?.subtitles?.paragraphs) {
      throw new Error('Invalid transcript data format');
    }

    // Check language
    const language = transcriptData.data.translation.language;
    if (language && language.englishName !== 'English') {
      console.log('Non-English transcript found:', language);
      throw new Error('Non-English transcript found');
    }

    // Process all cues from all paragraphs
    let allCues: TranscriptCueData[] = [];
    transcriptData.data.translation.subtitles.paragraphs.forEach((paragraph: any) => {
      if (paragraph.cues && Array.isArray(paragraph.cues)) {
        allCues.push(...paragraph.cues);
      }
    });

    if (allCues.length === 0) {
      throw new Error('No valid cues found');
    }

    // Sort by timestamp to ensure proper ordering
    allCues.sort((a, b) => a.time - b.time);

    // Sample check for Arabic content
    const sampleText = allCues.slice(0, 3).map(c => c.text).join(' ');
    if (containsArabic(sampleText)) {
      throw new Error('Arabic transcript detected');
    }

    console.log('First few cues:', allCues.slice(0, 5));

    // Convert to final format
    return allCues.map((cue, index) => {
      const startTime = parseFloat((cue.time / 1000).toFixed(2));
      const duration = parseFloat((cue.duration / 1000).toFixed(2));
      
      return {
        text: cue.text.trim(),
        start: startTime,
        end: startTime + duration
      };
    });

  } catch (error) {
    console.error('Error fetching TED transcript:', error);
    throw error;
  }
}

function processCues(cues: any[]): TranscriptCue[] {
  console.log('Processing', cues.length, 'cues');
  return cues.map((cue: any, index: number) => {
    const start = cue.time / 1000;
    let end;

    if (index < cues.length - 1) {
      end = cues[index + 1].time / 1000;
    } else {
      // For the last cue, add 3 seconds
      end = start + 3;
    }

    const text = cue.text.replace(/\\n/g, ' ').trim();
    console.log(`Cue ${index}: ${start}-${end} "${text.slice(0, 50)}..."`);

    return {
      text,
      start,
      end
    };
  });
}

async function tryAutoGeneratedCaptions(videoId: string): Promise<TranscriptCue[]> {
  const url = `https://www.youtube.com/api/timedtext?` +
    `v=${videoId}&` +
    `asr=true&` +
    `lang=en&` +
    `fmt=json3&` +
    `xorb=2&` +
    `xobt=3&` +
    `hl=en`;

  const response = await fetch(url, {
    headers: {
      'Accept-Language': 'en-US,en;q=0.9',
      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
      'Accept': 'application/json'
    }
  });

  if (!response.ok) {
    throw new Error(`YouTube API returned ${response.status}: ${response.statusText}`);
  }

  const text = await response.text(); // Get raw text first
  if (!text.trim()) {
    throw new Error('YouTube API returned empty response');
  }

  try {
    const data = JSON.parse(text);
    if (!data) {
      throw new Error('YouTube API returned null or undefined');
    }
    if (!data.events || !Array.isArray(data.events)) {
      throw new Error(`Invalid response structure: ${JSON.stringify(data).slice(0, 100)}...`);
    }

    const events = data.events.filter((event: any) => event.segs && event.segs[0]?.utf8);
    if (events.length === 0) {
      throw new Error('No valid caption segments found in response');
    }

    return events.map((event: any) => ({
      text: event.segs[0].utf8,
      start: event.tStartMs / 1000,
      end: (event.tStartMs + event.dDurationMs) / 1000
    }));
  } catch (error) {
    if (error instanceof SyntaxError) {
      // Log the first part of the response for debugging
      console.error('Invalid JSON response from YouTube. First 100 chars:', text.slice(0, 100));
      throw new Error(`Failed to parse YouTube response as JSON: ${error.message}`);
    }
    throw error; // Re-throw other errors
  }
}

async function tryManualCaptions(videoId: string): Promise<TranscriptCue[]> {
  const response = await fetch(
    `https://www.youtube.com/api/timedtext?` +
    `v=${videoId}&` +
    `lang=en&` +
    `name=&` +
    `fmt=srv3&` +
    `xorb=2&` +
    `xobt=3`,
    {
      headers: {
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      }
    }
  );

  const xml = await response.text();
  return parseXMLCaptions(xml);
}

async function tryLegacyFormat(videoId: string): Promise<TranscriptCue[]> {
  const response = await fetch(
    `https://www.youtube.com/api/timedtext?` +
    `v=${videoId}&` +
    `type=track&` +
    `lang=en&` +
    `name=&` +
    `kind=asr`,
    {
      headers: {
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      }
    }
  );

  const xml = await response.text();
  return parseXMLCaptions(xml);
}

async function tryWithTranslation(videoId: string): Promise<TranscriptCue[]> {
  const response = await fetch(
    `https://www.youtube.com/api/timedtext?` +
    `v=${videoId}&` +
    `tlang=en&` +
    `fmt=srv3&` +
    `xorb=2&` +
    `xobt=3`,
    {
      headers: {
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      }
    }
  );

  const xml = await response.text();
  return parseXMLCaptions(xml);
}

async function tryYTDLCore(videoId: string): Promise<TranscriptCue[]> {
  console.log('Attempting to fetch captions using ytdl-core...');
  
  try {
    const info = await ytdl.getInfo(videoId);
    console.log('Got video info from ytdl-core');

    // Try to get the caption URL from the video info
    const captionUrl = info.player_response.captions?.playerCaptionsTracklistRenderer?.captionTracks?.[0]?.baseUrl;
    if (!captionUrl) {
      throw new Error('No caption URL found in video info');
    }

    // Add parameters to get English captions
    const urlWithParams = new URL(captionUrl);
    urlWithParams.searchParams.set('lang', 'en');
    urlWithParams.searchParams.set('fmt', 'json3');
    urlWithParams.searchParams.set('xorb', '2');
    urlWithParams.searchParams.set('xobt', '3');
    urlWithParams.searchParams.set('tlang', 'en');

    console.log('Trying caption URL:', urlWithParams.toString());

    const response = await fetch(urlWithParams.toString(), {
      headers: {
        'Accept': 'application/json,text/plain,*/*',
        'Accept-Language': 'en-US,en;q=0.9',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      }
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch captions: ${response.status} ${response.statusText}`);
    }

    const text = await response.text();
    if (!text.trim()) {
      throw new Error('Empty response from caption URL');
    }

    try {
      // Try parsing as JSON3 format
      const data = JSON.parse(text);
      if (data.events) {
        return data.events
          .filter((event: any) => event.segs && event.segs[0]?.utf8)
          .map((event: any) => ({
            text: event.segs[0].utf8,
            start: event.tStartMs / 1000,
            end: (event.tStartMs + event.dDurationMs) / 1000
          }));
      }
    } catch (jsonError) {
      // If not JSON, try parsing as XML
      if (text.includes('<transcript>') || text.includes('<text')) {
        return parseXMLCaptions(text);
      }
      throw jsonError;
    }

    throw new Error('No valid caption data found in response');
  } catch (error) {
    console.error('ytdl-core error:', error);
    throw error;
  }
}

function parseXMLCaptions(xml: string): TranscriptCue[] {
  const cues: TranscriptCue[] = [];
  const matches = xml.matchAll(/<text start="([\d.]+)" dur="([\d.]+)".*?>(.*?)<\/text>/g);
  
  for (const match of matches) {
    const [_, start, duration, text] = match;
    cues.push({
      text: decodeHTML(text.trim()),
      start: parseFloat(start),
      end: parseFloat(start) + parseFloat(duration)
    });
  }

  return cues;
}

// Helper to decode HTML entities
function decodeHTML(text: string): string {
  return text
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, ' ');
}

// Helper to detect Arabic text
function containsArabic(text: string): boolean {
  const arabicPattern = /[\u0600-\u06FF]/;
  return arabicPattern.test(text);
}

async function tryYouTubeCaptionsScraper(videoId: string): Promise<TranscriptCue[]> {
  console.log('Attempting to fetch captions using youtube-captions-scraper...');
  
  try {
    // Try with different language options
    const options = [
      { lang: 'en' },                 // English
      { lang: 'en-US' },             // US English
      { lang: 'en-GB' },             // British English
      { lang: 'en', country: 'US' }, // Explicit country code
      {}                             // Default options (auto-detect)
    ];

    let lastError;
    for (const option of options) {
      try {
        console.log('Trying with options:', option);
        const subtitles = await getSubtitles({
          videoID: videoId,
          lang: option.lang || 'en'
        });
        
        if (subtitles && subtitles.length > 0) {
          // Convert to our format
          return subtitles.map((item: SubtitleItem) => ({
            text: item.text,
            start: parseFloat(item.start),
            end: parseFloat(item.start) + parseFloat(item.dur)
          }));
        }
      } catch (error) {
        lastError = error;
        console.log('Failed with options', option, ':', error);
      }
    }

    throw lastError || new Error('No subtitles found with any options');
  } catch (error) {
    console.error('youtube-captions-scraper error:', error);
    throw error;
  }
}

async function tryDirectYouTubeAPI(videoId: string): Promise<TranscriptCue[]> {
  console.log('Attempting to fetch captions directly from YouTube API...');
  
  try {
    // Try different formats and parameters
    const urls = [
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=json3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en-US&fmt=json3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv3`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&kind=asr`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&tlang=en`,
      `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&name=English`
    ];

    let lastError;
    for (const url of urls) {
      try {
        console.log('Trying URL:', url);
        const response = await fetch(url, {
          headers: {
            'Accept': 'application/json,text/plain,*/*',
            'Accept-Language': 'en-US,en;q=0.9',
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
          }
        });

        if (!response.ok) {
          console.log(`Failed with status ${response.status} for URL:`, url);
          continue;
        }

        const text = await response.text();
        if (!text.trim()) {
          console.log('Empty response for URL:', url);
          continue;
        }

        try {
          // Try parsing as JSON3 format
          const data = JSON.parse(text);
          if (data.events) {
            return data.events
              .filter((event: any) => event.segs && event.segs[0]?.utf8)
              .map((event: any) => ({
                text: event.segs[0].utf8,
                start: event.tStartMs / 1000,
                end: (event.tStartMs + event.dDurationMs) / 1000
              }));
          }
        } catch (jsonError) {
          // If not JSON, try parsing as XML
          if (text.includes('<transcript>') || text.includes('<text')) {
            return parseXMLCaptions(text);
          }
        }
      } catch (error) {
        lastError = error;
        console.log('Failed with URL', url, ':', error);
      }
    }

    throw lastError || new Error('No captions found with any URL');
  } catch (error) {
    console.error('Direct YouTube API error:', error);
    throw error;
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { url } = body;
    if (!url || typeof url !== 'string') {
      return NextResponse.json({ error: 'URL is required and must be a string' }, { status: 400 });
    }
    // Extract video ID from URL
    const match = url.match(/(?:v=|youtu\.be\/)([\w-]{11})/);
    const videoId = match ? match[1] : null;
    if (!videoId) {
      return NextResponse.json({ error: 'Invalid YouTube URL' }, { status: 400 });
    }
    // Call the Python microservice on port 5002
    const response = await fetch('http://localhost:5002/transcript', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ video_id: videoId }),
    });
    const data = await response.json();
    if (response.ok && data.transcript) {
      // Convert duration to end for each transcript item
      const transcript = data.transcript.map(
        (item: { text: string; start: number; duration: number }) => ({
          text: item.text,
          start: item.start,
          end: item.start + item.duration,
        })
      );
      return NextResponse.json({ transcript });
    } else {
      return NextResponse.json({ error: data.error || 'Failed to fetch transcript' }, { status: response.status });
    }
  } catch (error) {
    return NextResponse.json({ error: 'An unexpected error occurred', details: error instanceof Error ? error.message : String(error) }, { status: 500 });
  }
} 